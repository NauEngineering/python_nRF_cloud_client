# coding: utf-8

"""
    nRF Cloud REST API

    # Overview   The [nRF Cloud REST API](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html)   allows you to programmatically interact with, and retrieve historical information generated by, any device that you have   connected to <a href='https://nrfcloud.com'>nRFCloud.com</a>. This includes both IP-based devices–that is, devices that have an IP address and can talk directly to our   IoT platform–and Bluetooth Low Energy (BLE) devices, which require the use of an IP-based device (a gateway).  The REST API documentation is a supplement to the <a href='https://docs.nordicsemi.com/bundle/nrf-cloud/page/index.html'>main nRF Cloud documentation</a>.  [DevZone](https://devzone.nordicsemi.com) is Nordic Semiconductor's official tech support site and community. Get help from a dedicated tech support team and more than 25,000 other community members.  If you are encountering unexpected behavior or errors, check the current [status](https://status.nrfcloud.com) of nRF Cloud.  # Error Codes Some of the endpoints return specific error codes (called 'nRF Codes'), which can be found in this table.   <table>       <thead>       <tr>           <th style='width:10%'>nRF&nbsp;Code</th>           <th style='width:20%'>Error</th>           <th style='width:35%'>Reason</th>           <th style='width:35%'>Solution</th>       </tr>       </thead>       <tbody>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40000'>40000</div>           </td>           <td valign='top'>Bad request error.</td>           <td valign='top'>This error could mean many things. Most of the time it means something is not as expected               on the cloud like a file was missing or an internal service failed.           </td>           <td valign='top'>Alert Nordic support by filing a ticket on <a href='https://devzone.nordicsemi.com/'                                                                           target='_blank'>DevZone</a>.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40001'>40001</div>           </td>           <td valign='top'>Device does not have a valid device certificate for associating (adding) it to your               account.           </td>           <td valign='top'>Your nRF9160 DK device or Thingy:91 device does not have a 'just-in-time provisioning' (JITP) certificate, or               the certificate has been corrupted.           </td>           <td valign='top'>Refer to the <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/nrf9160_gs.html'>               nRF9160 DK Getting Started Guide</a> or <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/thingy91_gsg.html'>               Thingy:91 Getting Started Guide</a> for information on upgrading your device certificate.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40002'>40002</div>           </td>           <td valign='top'>Device cannot be dissociated (removed from your account).</td>           <td valign='top'>The nRF9160 DK or Thingy:91 you are trying to dissociate was added to your account using the legacy               pairing mechanism (button and switch pattern) instead of the <code>AssociateDevice</code> <a                       href='#operation/AssociateDevice'>endpoint</a>.           </td>           <td valign='top'>Delete the device from your account using either the <code>Configure</code> &gt; <code>Delete               Device</code> menu item on nrfcloud.com or the <code>DeleteDevice</code> <a                   href='#operation/DeleteDevice'>endpoint</a>. If you want to re-add this device to your account you               will first have to flash a new device certificate and upgrade the firmware. Refer to the <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/nrf9160_gs.html'>               nRF9160 DK Getting Started Guide</a> or <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/thingy91_gsg.html'>               Thingy:91 Getting Started Guide</a> for information on how to do this.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40005'>40005</div>           </td>           <td valign='top'>Usage limit exceeded.</td>           <td valign='top'>The API request exceeds one of the monthly usage limits defined on the               <a href='https://nrfcloud.com/#/pricing'>Pricing page</a> for users on the free Developer plan.           </td>           <td valign='top'>Wait until the beginning of the next month to continue your usage on the Developer               plan, or upgrade to the Pro or Enterprise plan.               See <a href='https://docs.nordicsemi.com/bundle/nrf-cloud/page/AccountAndTeamManagement/Plans/PlanOverview.html'>               nRF Cloud plans</a> to learn about the available plans, how to view your plan details and usage,               and how to upgrade your plan.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40100'>40100</div>           </td>           <td valign='top'>Access denied error.</td>           <td valign='top'>The user making the request does not have access to the requested resource (device, SIM,               invitation, etc.).           </td>           <td valign='top'>Confirm your authorization is correct. Refer to the endpoint's documentation to               determine if your request requires a Simple Token (API Key) or a JSON Web Token (JWT).               Some endpoints accept either.</td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40101'>40101</div>           </td>           <td valign='top'>Device is already associated with another account.</td>           <td valign='top'>Another user has already added this device to their account.</td>           <td valign='top'>If you know the other account owner you can request that they dissociate the device so that               you can add it to your account. Otherwise, this operation is not allowed.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40102'>40102</div>           </td>           <td valign='top'>The ownership code is invalid for this device.</td>           <td valign='top'>You entered the wrong ownership code (PIN or HWID) that is printed on the Nordic               Semiconductor product label, or which you submitted when creating a new device certificate.           </td>           <td valign='top'>Verify the PIN or HWID and enter it correctly.</td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40103'>40103</div>           </td>           <td valign='top'>This device is not associated with your account.</td>           <td valign='top'>The device you want to dissociate (remove from your account) is not found in your               account.           </td>           <td valign='top'>None. You are not allowed to do this.</td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40410'>40410</div>           </td>           <td valign='top'>Entity not found.           </td>           <td valign='top'>This error can be thrown for a variety of reasons, indicating that the entity could not be found by its ID. The entity could be a device, a certificate, or an API key, for example.           </td>           <td valign='top'>Refer to the associated message for details. For devices, confirm the device id you entered matches your existing device ID and that the device has not been deleted.               You can confirm using the <a href=\"/v1#operation/ListDevices\">ListDevices endpoint</a>.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40411'>40411</div>           </td>           <td valign='top'>A Nordic Semiconductor product with this device id and ownership code could not be found.           </td>           <td valign='top'>The device id you entered matches the format for a Nordic Semiconductor product, but the               device id and/or ownership code cannot be found in our system.           </td>           <td valign='top'>Compare the values you entered with what is printed on your product's label (for devices               with <code>IMEI</code> printed on the label, the device id will be <code>nrf-[IMEI]</code>, e.g., <code>nrf-123456789012345</code>).               If you submitted the correct values, please contact Nordic Semiconductor Tech Support for further               assistance.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40412'>40412</div>           </td>           <td valign='top'>No device found for this id. The device has not yet been provisioned.</td>           <td valign='top'>The device cannot be found in the nRF Cloud IoT device registry. The most likely reason               is that the device has not established an initial communication with the nRF Cloud MQTT broker, which               creates a new entry in the registry. Possible causes:<br><br>               <ol>                   <li>You entered the device id and/or ownership code (PIN or HWID) incorrectly.</li>                   <li>The device has not yet achieved an LTE connection, so it cannot contact nRF Cloud.</li>                   <li>The device has not completed the initial MQTT handshaking with nRF Cloud. Some hardware devices                       may indicate this completion using LED patterns.</li>                   <li>Corrupt modem firmware.</li>                   <li>Corrupt, wrongly flashed, or illegitimate device certificates.</li>                   <li>Poor LTE connection.</li>               </ol>           </td>           <td valign='top'>Solutions that match the possible reasons are listed here. For Nordic Semiconductor products,               refer to the <a href='https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/gsg_guides.html'>               Getting Started Guide</a> for your device.<br><br>               <ol>                   <li>Verify the values and try again. For Nordic Semiconductor products, please see the solution for                       nRF Code 40411, above.</li>                   <li>Ensure that the device's SIM card or eSIM is activated and functioning. If using an iBasis                       SIM card that is packaged with a Nordic Semiconductor product such as a Development                       Kit, activate the card on nrfcloud.com and then (re-)boot the device to connect.</li>                   <li>Check the LED status indicators to ensure the device indicates it has connected.</li>                   <li>(Re-)flash the latest modem firmware.</li>                   <li>Flash new device certificates obtained from the <code>CreateDeviceCertificate</code> <a                           href='#operation/CreateDeviceCertificate'> endpoint</a>.</li>                   <li>Move to a location with a better LTE connection.</li>               </ol>           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40413'>40413</div>           </td>           <td valign='top'>No device found for this id.</td>           <td valign='top'>You are trying to dissociate a device that is not found in your account (wrong device id),               or you are submitting the device's friendly name, not the id.           </td>           <td valign='top'>Verify you are passing the correct device id (not the friendly name you may have given               it).           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40414'>40414</div>           </td>           <td valign='top'>No device found for this id.</td>           <td valign='top'>You are trying to delete a device that was not found in your account or in the IoT registry               (i.e., provisioned, but not yet added to your account).           </td>           <td valign='top'><em>This may not be an error</em>, because the device may already be deleted. Verify you entered               the correct device id and ownership code (PIN or HWID on the label). For Nordic Semiconductor products,               see the solution for nRF Code 40411, above.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40420'>40420</div>           </td>           <td valign='top'>Resource not found.           </td>           <td valign='top'>This error can be thrown for a variety of reasons, indicating that a resource could not be found by its ID. The resource could be a device, a certificate, or an API key, for example.           </td>           <td valign='top'>Refer to the associated message for details. For devices, confirm the device id you entered matches your existing device ID and that the device has not been deleted.               You can confirm using the <a href=\"/v1#operation/ListDevices\">ListDevices endpoint</a>.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40499'>40499</div>           </td>           <td valign='top'>Not found, but no error.</td>           <td valign='top'>The requested item(s) do not exist, but there is no error.               For some requests, if the list to be returned is empty, this code and an explanatory message is               returned instead of an empty list.           </td>           <td valign='top'>No action is necessary.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/41600'>41600</div>           </td>           <td valign='top'>Range not satisfiable.</td>           <td valign='top'>You are calling an endpoint that uses the Range header and the byte range does not exist in               the target file or the range header itself is malformed.           </td>           <td valign='top'>Check the expected file size for the target file and ensure the range requested exists.               Refer to the <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range' target='_blank'>range                   header docs</a> for more information.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/42200'>42200</div>           </td>           <td valign='top'>Validation failed.</td>           <td valign='top'>You are calling an endpoint with invalid request data.</td>           <td valign='top'>Check the expected request format and try again.</td>       </tr>       </tbody>   </table> 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import Any, Optional
from typing_extensions import Annotated
from nrf_cloud_client.models.paginated_result_firmware import PaginatedResultFirmware
from nrf_cloud_client.models.rest_api_payload_content_type_with_zip import RestApiPayloadContentTypeWithZip
from nrf_cloud_client.models.upload_firmware202_response import UploadFirmware202Response

from nrf_cloud_client.api_client import ApiClient, RequestSerialized
from nrf_cloud_client.api_response import ApiResponse
from nrf_cloud_client.rest import RESTResponseType


class FirmwareBundlesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_firmware(
        self,
        bundle_id: Any,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """DeleteFirmware


        :param bundle_id: (required)
        :type bundle_id: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firmware_serialize(
            bundle_id=bundle_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firmware_with_http_info(
        self,
        bundle_id: Any,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """DeleteFirmware


        :param bundle_id: (required)
        :type bundle_id: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firmware_serialize(
            bundle_id=bundle_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firmware_without_preload_content(
        self,
        bundle_id: Any,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """DeleteFirmware


        :param bundle_id: (required)
        :type bundle_id: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firmware_serialize(
            bundle_id=bundle_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firmware_serialize(
        self,
        bundle_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bundle_id is not None:
            _path_params['bundleId'] = bundle_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/firmwares/{bundleId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_firmware(
        self,
        page_next_token: Optional[StrictStr] = None,
        page_limit: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = None,
        modem_only: Annotated[Optional[StrictBool], Field(description="Whether or not to return a list of modem firmware instead of the current tenant's firmware")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaginatedResultFirmware:
        """ListFirmware


        :param page_next_token:
        :type page_next_token: str
        :param page_limit:
        :type page_limit: int
        :param modem_only: Whether or not to return a list of modem firmware instead of the current tenant's firmware
        :type modem_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_firmware_serialize(
            page_next_token=page_next_token,
            page_limit=page_limit,
            modem_only=modem_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResultFirmware",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_firmware_with_http_info(
        self,
        page_next_token: Optional[StrictStr] = None,
        page_limit: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = None,
        modem_only: Annotated[Optional[StrictBool], Field(description="Whether or not to return a list of modem firmware instead of the current tenant's firmware")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaginatedResultFirmware]:
        """ListFirmware


        :param page_next_token:
        :type page_next_token: str
        :param page_limit:
        :type page_limit: int
        :param modem_only: Whether or not to return a list of modem firmware instead of the current tenant's firmware
        :type modem_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_firmware_serialize(
            page_next_token=page_next_token,
            page_limit=page_limit,
            modem_only=modem_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResultFirmware",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_firmware_without_preload_content(
        self,
        page_next_token: Optional[StrictStr] = None,
        page_limit: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = None,
        modem_only: Annotated[Optional[StrictBool], Field(description="Whether or not to return a list of modem firmware instead of the current tenant's firmware")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ListFirmware


        :param page_next_token:
        :type page_next_token: str
        :param page_limit:
        :type page_limit: int
        :param modem_only: Whether or not to return a list of modem firmware instead of the current tenant's firmware
        :type modem_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_firmware_serialize(
            page_next_token=page_next_token,
            page_limit=page_limit,
            modem_only=modem_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaginatedResultFirmware",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_firmware_serialize(
        self,
        page_next_token,
        page_limit,
        modem_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page_next_token is not None:
            
            _query_params.append(('pageNextToken', page_next_token))
            
        if page_limit is not None:
            
            _query_params.append(('pageLimit', page_limit))
            
        if modem_only is not None:
            
            _query_params.append(('modemOnly', modem_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/firmwares',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def upload_firmware(
        self,
        content_type: RestApiPayloadContentTypeWithZip,
        body: Annotated[str, Field(strict=True, max_length=1333333)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UploadFirmware202Response:
        """UploadFirmware

        Upload a firmware bundle as a .zip file, whether binary or base64-encoded. The bundle must contain a manifest.json file that conforms to this JSON schema: ``` {    name?: string,    description?: string,    fwversion: string,    'format-version': 1,    files: {      file: string,      type: 'application' | 'mcuboot' | 'bootloader' | 'softdevice' | 'init_packet',      size: number    }[]  } ``` Notes: - `?` fields are optional - `files` is an array of objects, all of which should be of the same `type`. - `file` must have a `.bin` extension. Host-side tools like [nRF Connect for Desktop Programmer](https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop) can be used to convert `.hex` files to `.bin`. - `type` values `application` and `mcuboot` apply only to nRF91 FOTA. Values `softdevice` and `init_packet` apply only to Bluetooth LE FOTA. - For Bluetooth LE devices using FOTA, the `.zip` file must contain both the init_packet and the firmware image (application or soft device). The `type` field for the manifest must be `application` or `softdevice`, not `init_packet`. - `'format-version'` should always be set to `1` - `fwversion` is validated against this regular expression: `/^[a-zA-Z0-9._-]{1,60}$/` - The Zephyr build system produces dfu_application.zip in the build/zephyr folder, which contains a manifest.json plus the update binary. However, the manifest is currently generated without the required `fwversion` field, so you will need to add that field. - If you use the nRFCloud.com user interface to upload your zip file, you are given options to fill in the `name`, `description`, and `fwversion` fields. The UI will then properly generate the manifest.json file and zip file. - Although nRF Cloud supports modem FOTA, we do not allow uploading modem firmware. These updates are made available only by Nordic Semiconductor.  An example of a valid manifest: ``` {    \"name\": \"My application update\",    \"description\": \"Changelog: Fixed an issue with sleep mode. Power consumption improvements.\",    \"fwversion\": \"1.1\",    \"format-version\": 1,    \"files\": [        {            \"file\": \"my_application_v1_1.hex.bin\",            \"type\": \"application\",            \"size\": 695672        }    ] } ``` Following are examples of uploading with curl (base64 and binary):  Using base64 encoded content: ```sh export FILE=$(base64 path/to/my-file.zip) # If you get a console error such as \"Argument list too long\" try using a REST client like Postman.  # UTF-8 curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain;charset=UTF8\" \\    -d $FILE  # ASCII curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain;charset=ASCII\" \\    -d $FILE  # Plain Text curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain\" \\    -d $FILE ``` Using binary content: ```sh # Octet-stream curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: application/octet-stream\" \\    --data-binary @/path/to/my-file.zip  # ZIP curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: application/zip\" \\    --data-binary @/path/to/my-file.zip ``` For more information, see the [FOTA documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/FirmwareUpdate/FOTAOverview.html).

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithZip
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_firmware_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "UploadFirmware202Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def upload_firmware_with_http_info(
        self,
        content_type: RestApiPayloadContentTypeWithZip,
        body: Annotated[str, Field(strict=True, max_length=1333333)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UploadFirmware202Response]:
        """UploadFirmware

        Upload a firmware bundle as a .zip file, whether binary or base64-encoded. The bundle must contain a manifest.json file that conforms to this JSON schema: ``` {    name?: string,    description?: string,    fwversion: string,    'format-version': 1,    files: {      file: string,      type: 'application' | 'mcuboot' | 'bootloader' | 'softdevice' | 'init_packet',      size: number    }[]  } ``` Notes: - `?` fields are optional - `files` is an array of objects, all of which should be of the same `type`. - `file` must have a `.bin` extension. Host-side tools like [nRF Connect for Desktop Programmer](https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop) can be used to convert `.hex` files to `.bin`. - `type` values `application` and `mcuboot` apply only to nRF91 FOTA. Values `softdevice` and `init_packet` apply only to Bluetooth LE FOTA. - For Bluetooth LE devices using FOTA, the `.zip` file must contain both the init_packet and the firmware image (application or soft device). The `type` field for the manifest must be `application` or `softdevice`, not `init_packet`. - `'format-version'` should always be set to `1` - `fwversion` is validated against this regular expression: `/^[a-zA-Z0-9._-]{1,60}$/` - The Zephyr build system produces dfu_application.zip in the build/zephyr folder, which contains a manifest.json plus the update binary. However, the manifest is currently generated without the required `fwversion` field, so you will need to add that field. - If you use the nRFCloud.com user interface to upload your zip file, you are given options to fill in the `name`, `description`, and `fwversion` fields. The UI will then properly generate the manifest.json file and zip file. - Although nRF Cloud supports modem FOTA, we do not allow uploading modem firmware. These updates are made available only by Nordic Semiconductor.  An example of a valid manifest: ``` {    \"name\": \"My application update\",    \"description\": \"Changelog: Fixed an issue with sleep mode. Power consumption improvements.\",    \"fwversion\": \"1.1\",    \"format-version\": 1,    \"files\": [        {            \"file\": \"my_application_v1_1.hex.bin\",            \"type\": \"application\",            \"size\": 695672        }    ] } ``` Following are examples of uploading with curl (base64 and binary):  Using base64 encoded content: ```sh export FILE=$(base64 path/to/my-file.zip) # If you get a console error such as \"Argument list too long\" try using a REST client like Postman.  # UTF-8 curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain;charset=UTF8\" \\    -d $FILE  # ASCII curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain;charset=ASCII\" \\    -d $FILE  # Plain Text curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain\" \\    -d $FILE ``` Using binary content: ```sh # Octet-stream curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: application/octet-stream\" \\    --data-binary @/path/to/my-file.zip  # ZIP curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: application/zip\" \\    --data-binary @/path/to/my-file.zip ``` For more information, see the [FOTA documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/FirmwareUpdate/FOTAOverview.html).

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithZip
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_firmware_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "UploadFirmware202Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def upload_firmware_without_preload_content(
        self,
        content_type: RestApiPayloadContentTypeWithZip,
        body: Annotated[str, Field(strict=True, max_length=1333333)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """UploadFirmware

        Upload a firmware bundle as a .zip file, whether binary or base64-encoded. The bundle must contain a manifest.json file that conforms to this JSON schema: ``` {    name?: string,    description?: string,    fwversion: string,    'format-version': 1,    files: {      file: string,      type: 'application' | 'mcuboot' | 'bootloader' | 'softdevice' | 'init_packet',      size: number    }[]  } ``` Notes: - `?` fields are optional - `files` is an array of objects, all of which should be of the same `type`. - `file` must have a `.bin` extension. Host-side tools like [nRF Connect for Desktop Programmer](https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop) can be used to convert `.hex` files to `.bin`. - `type` values `application` and `mcuboot` apply only to nRF91 FOTA. Values `softdevice` and `init_packet` apply only to Bluetooth LE FOTA. - For Bluetooth LE devices using FOTA, the `.zip` file must contain both the init_packet and the firmware image (application or soft device). The `type` field for the manifest must be `application` or `softdevice`, not `init_packet`. - `'format-version'` should always be set to `1` - `fwversion` is validated against this regular expression: `/^[a-zA-Z0-9._-]{1,60}$/` - The Zephyr build system produces dfu_application.zip in the build/zephyr folder, which contains a manifest.json plus the update binary. However, the manifest is currently generated without the required `fwversion` field, so you will need to add that field. - If you use the nRFCloud.com user interface to upload your zip file, you are given options to fill in the `name`, `description`, and `fwversion` fields. The UI will then properly generate the manifest.json file and zip file. - Although nRF Cloud supports modem FOTA, we do not allow uploading modem firmware. These updates are made available only by Nordic Semiconductor.  An example of a valid manifest: ``` {    \"name\": \"My application update\",    \"description\": \"Changelog: Fixed an issue with sleep mode. Power consumption improvements.\",    \"fwversion\": \"1.1\",    \"format-version\": 1,    \"files\": [        {            \"file\": \"my_application_v1_1.hex.bin\",            \"type\": \"application\",            \"size\": 695672        }    ] } ``` Following are examples of uploading with curl (base64 and binary):  Using base64 encoded content: ```sh export FILE=$(base64 path/to/my-file.zip) # If you get a console error such as \"Argument list too long\" try using a REST client like Postman.  # UTF-8 curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain;charset=UTF8\" \\    -d $FILE  # ASCII curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain;charset=ASCII\" \\    -d $FILE  # Plain Text curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: text/plain\" \\    -d $FILE ``` Using binary content: ```sh # Octet-stream curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: application/octet-stream\" \\    --data-binary @/path/to/my-file.zip  # ZIP curl -X POST $API_HOST/v1/firmwares \\    -H \"Authorization: Bearer $API_KEY\" \\    -H \"Content-Type: application/zip\" \\    --data-binary @/path/to/my-file.zip ``` For more information, see the [FOTA documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/FirmwareUpdate/FOTAOverview.html).

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithZip
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_firmware_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "UploadFirmware202Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _upload_firmware_serialize(
        self,
        content_type,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['content-type'] = content_type
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/firmwares',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


