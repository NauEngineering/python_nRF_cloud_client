# coding: utf-8

"""
    nRF Cloud REST API

    # Overview   The [nRF Cloud REST API](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html)   allows you to programmatically interact with, and retrieve historical information generated by, any device that you have   connected to <a href='https://nrfcloud.com'>nRFCloud.com</a>. This includes both IP-based devices–that is, devices that have an IP address and can talk directly to our   IoT platform–and Bluetooth Low Energy (BLE) devices, which require the use of an IP-based device (a gateway).  The REST API documentation is a supplement to the <a href='https://docs.nordicsemi.com/bundle/nrf-cloud/page/index.html'>main nRF Cloud documentation</a>.  [DevZone](https://devzone.nordicsemi.com) is Nordic Semiconductor's official tech support site and community. Get help from a dedicated tech support team and more than 25,000 other community members.  If you are encountering unexpected behavior or errors, check the current [status](https://status.nrfcloud.com) of nRF Cloud.  # Error Codes Some of the endpoints return specific error codes (called 'nRF Codes'), which can be found in this table.   <table>       <thead>       <tr>           <th style='width:10%'>nRF&nbsp;Code</th>           <th style='width:20%'>Error</th>           <th style='width:35%'>Reason</th>           <th style='width:35%'>Solution</th>       </tr>       </thead>       <tbody>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40000'>40000</div>           </td>           <td valign='top'>Bad request error.</td>           <td valign='top'>This error could mean many things. Most of the time it means something is not as expected               on the cloud like a file was missing or an internal service failed.           </td>           <td valign='top'>Alert Nordic support by filing a ticket on <a href='https://devzone.nordicsemi.com/'                                                                           target='_blank'>DevZone</a>.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40001'>40001</div>           </td>           <td valign='top'>Device does not have a valid device certificate for associating (adding) it to your               account.           </td>           <td valign='top'>Your nRF9160 DK device or Thingy:91 device does not have a 'just-in-time provisioning' (JITP) certificate, or               the certificate has been corrupted.           </td>           <td valign='top'>Refer to the <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/nrf9160_gs.html'>               nRF9160 DK Getting Started Guide</a> or <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/thingy91_gsg.html'>               Thingy:91 Getting Started Guide</a> for information on upgrading your device certificate.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40002'>40002</div>           </td>           <td valign='top'>Device cannot be dissociated (removed from your account).</td>           <td valign='top'>The nRF9160 DK or Thingy:91 you are trying to dissociate was added to your account using the legacy               pairing mechanism (button and switch pattern) instead of the <code>AssociateDevice</code> <a                       href='#operation/AssociateDevice'>endpoint</a>.           </td>           <td valign='top'>Delete the device from your account using either the <code>Configure</code> &gt; <code>Delete               Device</code> menu item on nrfcloud.com or the <code>DeleteDevice</code> <a                   href='#operation/DeleteDevice'>endpoint</a>. If you want to re-add this device to your account you               will first have to flash a new device certificate and upgrade the firmware. Refer to the <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/nrf9160_gs.html'>               nRF9160 DK Getting Started Guide</a> or <a                   href='https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrf/working_with_nrf/nrf91/thingy91_gsg.html'>               Thingy:91 Getting Started Guide</a> for information on how to do this.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40005'>40005</div>           </td>           <td valign='top'>Usage limit exceeded.</td>           <td valign='top'>The API request exceeds one of the monthly usage limits defined on the               <a href='https://nrfcloud.com/#/pricing'>Pricing page</a> for users on the free Developer plan.           </td>           <td valign='top'>Wait until the beginning of the next month to continue your usage on the Developer               plan, or upgrade to the Pro or Enterprise plan.               See <a href='https://docs.nordicsemi.com/bundle/nrf-cloud/page/AccountAndTeamManagement/Plans/PlanOverview.html'>               nRF Cloud plans</a> to learn about the available plans, how to view your plan details and usage,               and how to upgrade your plan.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40100'>40100</div>           </td>           <td valign='top'>Access denied error.</td>           <td valign='top'>The user making the request does not have access to the requested resource (device, SIM,               invitation, etc.).           </td>           <td valign='top'>Confirm your authorization is correct. Refer to the endpoint's documentation to               determine if your request requires a Simple Token (API Key) or a JSON Web Token (JWT).               Some endpoints accept either.</td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40101'>40101</div>           </td>           <td valign='top'>Device is already associated with another account.</td>           <td valign='top'>Another user has already added this device to their account.</td>           <td valign='top'>If you know the other account owner you can request that they dissociate the device so that               you can add it to your account. Otherwise, this operation is not allowed.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40102'>40102</div>           </td>           <td valign='top'>The ownership code is invalid for this device.</td>           <td valign='top'>You entered the wrong ownership code (PIN or HWID) that is printed on the Nordic               Semiconductor product label, or which you submitted when creating a new device certificate.           </td>           <td valign='top'>Verify the PIN or HWID and enter it correctly.</td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40103'>40103</div>           </td>           <td valign='top'>This device is not associated with your account.</td>           <td valign='top'>The device you want to dissociate (remove from your account) is not found in your               account.           </td>           <td valign='top'>None. You are not allowed to do this.</td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40410'>40410</div>           </td>           <td valign='top'>Entity not found.           </td>           <td valign='top'>This error can be thrown for a variety of reasons, indicating that the entity could not be found by its ID. The entity could be a device, a certificate, or an API key, for example.           </td>           <td valign='top'>Refer to the associated message for details. For devices, confirm the device id you entered matches your existing device ID and that the device has not been deleted.               You can confirm using the <a href=\"/v1#operation/ListDevices\">ListDevices endpoint</a>.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40411'>40411</div>           </td>           <td valign='top'>A Nordic Semiconductor product with this device id and ownership code could not be found.           </td>           <td valign='top'>The device id you entered matches the format for a Nordic Semiconductor product, but the               device id and/or ownership code cannot be found in our system.           </td>           <td valign='top'>Compare the values you entered with what is printed on your product's label (for devices               with <code>IMEI</code> printed on the label, the device id will be <code>nrf-[IMEI]</code>, e.g., <code>nrf-123456789012345</code>).               If you submitted the correct values, please contact Nordic Semiconductor Tech Support for further               assistance.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40412'>40412</div>           </td>           <td valign='top'>No device found for this id. The device has not yet been provisioned.</td>           <td valign='top'>The device cannot be found in the nRF Cloud IoT device registry. The most likely reason               is that the device has not established an initial communication with the nRF Cloud MQTT broker, which               creates a new entry in the registry. Possible causes:<br><br>               <ol>                   <li>You entered the device id and/or ownership code (PIN or HWID) incorrectly.</li>                   <li>The device has not yet achieved an LTE connection, so it cannot contact nRF Cloud.</li>                   <li>The device has not completed the initial MQTT handshaking with nRF Cloud. Some hardware devices                       may indicate this completion using LED patterns.</li>                   <li>Corrupt modem firmware.</li>                   <li>Corrupt, wrongly flashed, or illegitimate device certificates.</li>                   <li>Poor LTE connection.</li>               </ol>           </td>           <td valign='top'>Solutions that match the possible reasons are listed here. For Nordic Semiconductor products,               refer to the <a href='https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/gsg_guides.html'>               Getting Started Guide</a> for your device.<br><br>               <ol>                   <li>Verify the values and try again. For Nordic Semiconductor products, please see the solution for                       nRF Code 40411, above.</li>                   <li>Ensure that the device's SIM card or eSIM is activated and functioning. If using an iBasis                       SIM card that is packaged with a Nordic Semiconductor product such as a Development                       Kit, activate the card on nrfcloud.com and then (re-)boot the device to connect.</li>                   <li>Check the LED status indicators to ensure the device indicates it has connected.</li>                   <li>(Re-)flash the latest modem firmware.</li>                   <li>Flash new device certificates obtained from the <code>CreateDeviceCertificate</code> <a                           href='#operation/CreateDeviceCertificate'> endpoint</a>.</li>                   <li>Move to a location with a better LTE connection.</li>               </ol>           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40413'>40413</div>           </td>           <td valign='top'>No device found for this id.</td>           <td valign='top'>You are trying to dissociate a device that is not found in your account (wrong device id),               or you are submitting the device's friendly name, not the id.           </td>           <td valign='top'>Verify you are passing the correct device id (not the friendly name you may have given               it).           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40414'>40414</div>           </td>           <td valign='top'>No device found for this id.</td>           <td valign='top'>You are trying to delete a device that was not found in your account or in the IoT registry               (i.e., provisioned, but not yet added to your account).           </td>           <td valign='top'><em>This may not be an error</em>, because the device may already be deleted. Verify you entered               the correct device id and ownership code (PIN or HWID on the label). For Nordic Semiconductor products,               see the solution for nRF Code 40411, above.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40420'>40420</div>           </td>           <td valign='top'>Resource not found.           </td>           <td valign='top'>This error can be thrown for a variety of reasons, indicating that a resource could not be found by its ID. The resource could be a device, a certificate, or an API key, for example.           </td>           <td valign='top'>Refer to the associated message for details. For devices, confirm the device id you entered matches your existing device ID and that the device has not been deleted.               You can confirm using the <a href=\"/v1#operation/ListDevices\">ListDevices endpoint</a>.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/40499'>40499</div>           </td>           <td valign='top'>Not found, but no error.</td>           <td valign='top'>The requested item(s) do not exist, but there is no error.               For some requests, if the list to be returned is empty, this code and an explanatory message is               returned instead of an empty list.           </td>           <td valign='top'>No action is necessary.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/41600'>41600</div>           </td>           <td valign='top'>Range not satisfiable.</td>           <td valign='top'>You are calling an endpoint that uses the Range header and the byte range does not exist in               the target file or the range header itself is malformed.           </td>           <td valign='top'>Check the expected file size for the target file and ensure the range requested exists.               Refer to the <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range' target='_blank'>range                   header docs</a> for more information.           </td>       </tr>       <tr>           <td valign='top'>               <div data-section-id='section/Error-Codes/42200'>42200</div>           </td>           <td valign='top'>Validation failed.</td>           <td valign='top'>You are calling an endpoint with invalid request data.</td>           <td valign='top'>Check the expected request format and try again.</td>       </tr>       </tbody>   </table> 

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from nrf_cloud_client.models.device_certificate import DeviceCertificate
from nrf_cloud_client.models.device_state_input import DeviceStateInput
from nrf_cloud_client.models.onboard_devices202_response import OnboardDevices202Response
from nrf_cloud_client.models.onboard_single_device_args import OnboardSingleDeviceArgs
from nrf_cloud_client.models.rest_api_payload_content_type_with_csv import RestApiPayloadContentTypeWithCsv

from nrf_cloud_client.api_client import ApiClient, RequestSerialized
from nrf_cloud_client.api_response import ApiResponse
from nrf_cloud_client.rest import RESTResponseType


class IPDevicesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def associate_device(
        self,
        device_id: Annotated[str, Field(strict=True)],
        body: StrictStr,
        sub_type: Optional[Annotated[str, Field(strict=True)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """AssociateDevice

        Add a device to your nRF Cloud account. The association process is idempotent. You may therefore use this endpoint to update your device's `subType`. For more on the use of `subType` see the [OnboardDevices endpoint](#operation/OnboardDevices). ```sh curl -X PUT $API_HOST/v1/association/$DEVICE_ID -d \"$DEVICE_OWNERSHIP_CODE\" -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: text/plain\" ```

        :param device_id: (required)
        :type device_id: str
        :param body: (required)
        :type body: str
        :param sub_type:
        :type sub_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_device_serialize(
            device_id=device_id,
            body=body,
            sub_type=sub_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def associate_device_with_http_info(
        self,
        device_id: Annotated[str, Field(strict=True)],
        body: StrictStr,
        sub_type: Optional[Annotated[str, Field(strict=True)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """AssociateDevice

        Add a device to your nRF Cloud account. The association process is idempotent. You may therefore use this endpoint to update your device's `subType`. For more on the use of `subType` see the [OnboardDevices endpoint](#operation/OnboardDevices). ```sh curl -X PUT $API_HOST/v1/association/$DEVICE_ID -d \"$DEVICE_OWNERSHIP_CODE\" -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: text/plain\" ```

        :param device_id: (required)
        :type device_id: str
        :param body: (required)
        :type body: str
        :param sub_type:
        :type sub_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_device_serialize(
            device_id=device_id,
            body=body,
            sub_type=sub_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def associate_device_without_preload_content(
        self,
        device_id: Annotated[str, Field(strict=True)],
        body: StrictStr,
        sub_type: Optional[Annotated[str, Field(strict=True)]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """AssociateDevice

        Add a device to your nRF Cloud account. The association process is idempotent. You may therefore use this endpoint to update your device's `subType`. For more on the use of `subType` see the [OnboardDevices endpoint](#operation/OnboardDevices). ```sh curl -X PUT $API_HOST/v1/association/$DEVICE_ID -d \"$DEVICE_OWNERSHIP_CODE\" -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: text/plain\" ```

        :param device_id: (required)
        :type device_id: str
        :param body: (required)
        :type body: str
        :param sub_type:
        :type sub_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_device_serialize(
            device_id=device_id,
            body=body,
            sub_type=sub_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _associate_device_serialize(
        self,
        device_id,
        body,
        sub_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if device_id is not None:
            _path_params['deviceId'] = device_id
        # process the query parameters
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/association/{deviceId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_device_certificate(
        self,
        device_id: Annotated[str, Field(strict=True)],
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeviceCertificate:
        """CreateDeviceCertificate

        <div style=\"background-color: #f8d7da; color: #721c24; text-align: center; border: 1px solid #f5c6cb; border-radius: .25rem; padding: .75rem 1.25rem\">This endpoint has been deprecated. Please use the <a href=\"#tag/IP-Devices/operation/OnboardDevice\">OnboardDevice endpoint</a> instead.</div> Creates a just-in-time-provisioning (JITP) certificate for a device using Nordic's registered CA certificate. Consider this a convenience endpoint for obtaining a device certificate, with the following disadvantages:  1. The JITP process takes approximately 30 seconds and involves multiple connects and disconnects between your MQTT client and the AWS IoT broker. 2. You cannot use your own CA certificate. 3. This endpoint does not support bulk operations. 4. You will have to explicitly [associate](/v1#operation/AssociateDevice) a JITP device with your account.   For this JITP certificate to work properly the device must not yet be provisioned (created) on our platform. If you are creating a certificate for a device that you have already connected to our platform, please delete the device using the `DeleteDevice` [endpoint](#operation/DeleteDevice) before using this certificate.  For a Nordic Semiconductor product such as an nRF9160-DK or a Thingy-91, the `deviceId` is `nrf-[IMEI]`, e.g., `nrf-111222333444555`. The IMEI can be found on your product's label.  If you want to create a certificate for a non-Nordic device, any `deviceId` is sufficient that does not start with `nrf-` (we recommend using a GUID). ```sh curl -X POST $API_HOST/v1/devices/$DEVICE_ID/certificates -d \"$DEVICE_OWNERSHIP_CODE\" -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: text/plain\" ```

        :param device_id: (required)
        :type device_id: str
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_device_certificate_serialize(
            device_id=device_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DeviceCertificate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_device_certificate_with_http_info(
        self,
        device_id: Annotated[str, Field(strict=True)],
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeviceCertificate]:
        """CreateDeviceCertificate

        <div style=\"background-color: #f8d7da; color: #721c24; text-align: center; border: 1px solid #f5c6cb; border-radius: .25rem; padding: .75rem 1.25rem\">This endpoint has been deprecated. Please use the <a href=\"#tag/IP-Devices/operation/OnboardDevice\">OnboardDevice endpoint</a> instead.</div> Creates a just-in-time-provisioning (JITP) certificate for a device using Nordic's registered CA certificate. Consider this a convenience endpoint for obtaining a device certificate, with the following disadvantages:  1. The JITP process takes approximately 30 seconds and involves multiple connects and disconnects between your MQTT client and the AWS IoT broker. 2. You cannot use your own CA certificate. 3. This endpoint does not support bulk operations. 4. You will have to explicitly [associate](/v1#operation/AssociateDevice) a JITP device with your account.   For this JITP certificate to work properly the device must not yet be provisioned (created) on our platform. If you are creating a certificate for a device that you have already connected to our platform, please delete the device using the `DeleteDevice` [endpoint](#operation/DeleteDevice) before using this certificate.  For a Nordic Semiconductor product such as an nRF9160-DK or a Thingy-91, the `deviceId` is `nrf-[IMEI]`, e.g., `nrf-111222333444555`. The IMEI can be found on your product's label.  If you want to create a certificate for a non-Nordic device, any `deviceId` is sufficient that does not start with `nrf-` (we recommend using a GUID). ```sh curl -X POST $API_HOST/v1/devices/$DEVICE_ID/certificates -d \"$DEVICE_OWNERSHIP_CODE\" -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: text/plain\" ```

        :param device_id: (required)
        :type device_id: str
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_device_certificate_serialize(
            device_id=device_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DeviceCertificate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_device_certificate_without_preload_content(
        self,
        device_id: Annotated[str, Field(strict=True)],
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """CreateDeviceCertificate

        <div style=\"background-color: #f8d7da; color: #721c24; text-align: center; border: 1px solid #f5c6cb; border-radius: .25rem; padding: .75rem 1.25rem\">This endpoint has been deprecated. Please use the <a href=\"#tag/IP-Devices/operation/OnboardDevice\">OnboardDevice endpoint</a> instead.</div> Creates a just-in-time-provisioning (JITP) certificate for a device using Nordic's registered CA certificate. Consider this a convenience endpoint for obtaining a device certificate, with the following disadvantages:  1. The JITP process takes approximately 30 seconds and involves multiple connects and disconnects between your MQTT client and the AWS IoT broker. 2. You cannot use your own CA certificate. 3. This endpoint does not support bulk operations. 4. You will have to explicitly [associate](/v1#operation/AssociateDevice) a JITP device with your account.   For this JITP certificate to work properly the device must not yet be provisioned (created) on our platform. If you are creating a certificate for a device that you have already connected to our platform, please delete the device using the `DeleteDevice` [endpoint](#operation/DeleteDevice) before using this certificate.  For a Nordic Semiconductor product such as an nRF9160-DK or a Thingy-91, the `deviceId` is `nrf-[IMEI]`, e.g., `nrf-111222333444555`. The IMEI can be found on your product's label.  If you want to create a certificate for a non-Nordic device, any `deviceId` is sufficient that does not start with `nrf-` (we recommend using a GUID). ```sh curl -X POST $API_HOST/v1/devices/$DEVICE_ID/certificates -d \"$DEVICE_OWNERSHIP_CODE\" -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: text/plain\" ```

        :param device_id: (required)
        :type device_id: str
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_device_certificate_serialize(
            device_id=device_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DeviceCertificate",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_device_certificate_serialize(
        self,
        device_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if device_id is not None:
            _path_params['deviceId'] = device_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/devices/{deviceId}/certificates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def dissociate_device(
        self,
        device_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """(Deprecated) DissociateDevice

        <div style=\"background-color: #f8d7da; color: #721c24; text-align: center; border: 1px solid #f5c6cb; border-radius: .25rem; padding: .75rem 1.25rem\">This endpoint has been deprecated. Please use the <a href=\"#operation/DeleteDevice\">DeleteDevice endpoint</a> instead.</div>  Remove a device from your nRF Cloud account. This does not delete (unprovision) it on nRF Cloud. ```sh curl -X DELETE $API_HOST/v1/association/$DEVICE_ID -H \"Authorization: Bearer $API_KEY\" ```

        :param device_id: (required)
        :type device_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /association/{deviceId} is deprecated.", DeprecationWarning)

        _param = self._dissociate_device_serialize(
            device_id=device_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def dissociate_device_with_http_info(
        self,
        device_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """(Deprecated) DissociateDevice

        <div style=\"background-color: #f8d7da; color: #721c24; text-align: center; border: 1px solid #f5c6cb; border-radius: .25rem; padding: .75rem 1.25rem\">This endpoint has been deprecated. Please use the <a href=\"#operation/DeleteDevice\">DeleteDevice endpoint</a> instead.</div>  Remove a device from your nRF Cloud account. This does not delete (unprovision) it on nRF Cloud. ```sh curl -X DELETE $API_HOST/v1/association/$DEVICE_ID -H \"Authorization: Bearer $API_KEY\" ```

        :param device_id: (required)
        :type device_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /association/{deviceId} is deprecated.", DeprecationWarning)

        _param = self._dissociate_device_serialize(
            device_id=device_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def dissociate_device_without_preload_content(
        self,
        device_id: Annotated[str, Field(strict=True)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) DissociateDevice

        <div style=\"background-color: #f8d7da; color: #721c24; text-align: center; border: 1px solid #f5c6cb; border-radius: .25rem; padding: .75rem 1.25rem\">This endpoint has been deprecated. Please use the <a href=\"#operation/DeleteDevice\">DeleteDevice endpoint</a> instead.</div>  Remove a device from your nRF Cloud account. This does not delete (unprovision) it on nRF Cloud. ```sh curl -X DELETE $API_HOST/v1/association/$DEVICE_ID -H \"Authorization: Bearer $API_KEY\" ```

        :param device_id: (required)
        :type device_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /association/{deviceId} is deprecated.", DeprecationWarning)

        _param = self._dissociate_device_serialize(
            device_id=device_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _dissociate_device_serialize(
        self,
        device_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if device_id is not None:
            _path_params['deviceId'] = device_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/association/{deviceId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def onboard_device(
        self,
        device_id: Annotated[str, Field(strict=True)],
        onboard_single_device_args: OnboardSingleDeviceArgs,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """OnboardDevice

        [Onboard](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) and associate a single device with your nRF Cloud account.  This endpoint supports two onboarding modalities depending upon whether you include device certificates or public keys in your payload.  Uploading a device certificate allows the device to use nRF Cloud services using any supported connectivity protocol, such as HTTP/REST, MQTT, and CoAP. This is the recommended method for onboarding devices. Unlike the [CreateDeviceCertificate endpoint](#operation/CreateDeviceCertificate), this endpoint involves your own CA certificate and requires you to upload device certificates that you have already obtained, whether via a CSR produced by the `AT%KEYGEN` command (modem firmware v1.3+), or offline via your own script. We impose no rules on your CA certificate, and a self-signed certificate may be used. For more information see [Onboarding](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) in the nRF Cloud documentation.  Whether using our APIs via REST or MQTT you will need to flash to your device: 1. <a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem\" target=\"_blank\">The Amazon Root CA1 PEM file</a>, which enables the device to authenticate the AWS IoT server. 2. The private key associated with the device certificate.  Additionally, if the device will be using MQTT, you will also need to flash the device certificate. For [signing JWTs](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) you will use the private key associated with the certificate. (During the device onboarding process we extract the corresponding public key from your uploaded certificate and use this for JWT signature verification.)  The second onboarding modality involves uploading a public key to verify the signatures of [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device. Uploading a public key allows the device to use  [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) signed by the private key of an asymmetric key pair, i.e., a private key that is different than the one used to sign the device's CSR (this key pair can be generated via the AT%KEYGEN command). If you are using JWTs signed by the device CSR key, and you have also uploaded the device's certificate via this or the [OnboardDevices endpoint](#operation/OnboardDevices), there is no need to upload the public key, because it is automatically extracted from the certificate. This is useful for devices that only want to consume nRF Cloud services over REST.  Please note: Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  For bulk onboarding of devices, please use the [OnboardDevices endpoint](#operation/OnboardDevices).

        :param device_id: (required)
        :type device_id: str
        :param onboard_single_device_args: (required)
        :type onboard_single_device_args: OnboardSingleDeviceArgs
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._onboard_device_serialize(
            device_id=device_id,
            onboard_single_device_args=onboard_single_device_args,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def onboard_device_with_http_info(
        self,
        device_id: Annotated[str, Field(strict=True)],
        onboard_single_device_args: OnboardSingleDeviceArgs,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """OnboardDevice

        [Onboard](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) and associate a single device with your nRF Cloud account.  This endpoint supports two onboarding modalities depending upon whether you include device certificates or public keys in your payload.  Uploading a device certificate allows the device to use nRF Cloud services using any supported connectivity protocol, such as HTTP/REST, MQTT, and CoAP. This is the recommended method for onboarding devices. Unlike the [CreateDeviceCertificate endpoint](#operation/CreateDeviceCertificate), this endpoint involves your own CA certificate and requires you to upload device certificates that you have already obtained, whether via a CSR produced by the `AT%KEYGEN` command (modem firmware v1.3+), or offline via your own script. We impose no rules on your CA certificate, and a self-signed certificate may be used. For more information see [Onboarding](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) in the nRF Cloud documentation.  Whether using our APIs via REST or MQTT you will need to flash to your device: 1. <a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem\" target=\"_blank\">The Amazon Root CA1 PEM file</a>, which enables the device to authenticate the AWS IoT server. 2. The private key associated with the device certificate.  Additionally, if the device will be using MQTT, you will also need to flash the device certificate. For [signing JWTs](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) you will use the private key associated with the certificate. (During the device onboarding process we extract the corresponding public key from your uploaded certificate and use this for JWT signature verification.)  The second onboarding modality involves uploading a public key to verify the signatures of [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device. Uploading a public key allows the device to use  [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) signed by the private key of an asymmetric key pair, i.e., a private key that is different than the one used to sign the device's CSR (this key pair can be generated via the AT%KEYGEN command). If you are using JWTs signed by the device CSR key, and you have also uploaded the device's certificate via this or the [OnboardDevices endpoint](#operation/OnboardDevices), there is no need to upload the public key, because it is automatically extracted from the certificate. This is useful for devices that only want to consume nRF Cloud services over REST.  Please note: Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  For bulk onboarding of devices, please use the [OnboardDevices endpoint](#operation/OnboardDevices).

        :param device_id: (required)
        :type device_id: str
        :param onboard_single_device_args: (required)
        :type onboard_single_device_args: OnboardSingleDeviceArgs
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._onboard_device_serialize(
            device_id=device_id,
            onboard_single_device_args=onboard_single_device_args,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def onboard_device_without_preload_content(
        self,
        device_id: Annotated[str, Field(strict=True)],
        onboard_single_device_args: OnboardSingleDeviceArgs,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """OnboardDevice

        [Onboard](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) and associate a single device with your nRF Cloud account.  This endpoint supports two onboarding modalities depending upon whether you include device certificates or public keys in your payload.  Uploading a device certificate allows the device to use nRF Cloud services using any supported connectivity protocol, such as HTTP/REST, MQTT, and CoAP. This is the recommended method for onboarding devices. Unlike the [CreateDeviceCertificate endpoint](#operation/CreateDeviceCertificate), this endpoint involves your own CA certificate and requires you to upload device certificates that you have already obtained, whether via a CSR produced by the `AT%KEYGEN` command (modem firmware v1.3+), or offline via your own script. We impose no rules on your CA certificate, and a self-signed certificate may be used. For more information see [Onboarding](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) in the nRF Cloud documentation.  Whether using our APIs via REST or MQTT you will need to flash to your device: 1. <a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem\" target=\"_blank\">The Amazon Root CA1 PEM file</a>, which enables the device to authenticate the AWS IoT server. 2. The private key associated with the device certificate.  Additionally, if the device will be using MQTT, you will also need to flash the device certificate. For [signing JWTs](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) you will use the private key associated with the certificate. (During the device onboarding process we extract the corresponding public key from your uploaded certificate and use this for JWT signature verification.)  The second onboarding modality involves uploading a public key to verify the signatures of [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device. Uploading a public key allows the device to use  [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) signed by the private key of an asymmetric key pair, i.e., a private key that is different than the one used to sign the device's CSR (this key pair can be generated via the AT%KEYGEN command). If you are using JWTs signed by the device CSR key, and you have also uploaded the device's certificate via this or the [OnboardDevices endpoint](#operation/OnboardDevices), there is no need to upload the public key, because it is automatically extracted from the certificate. This is useful for devices that only want to consume nRF Cloud services over REST.  Please note: Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  For bulk onboarding of devices, please use the [OnboardDevices endpoint](#operation/OnboardDevices).

        :param device_id: (required)
        :type device_id: str
        :param onboard_single_device_args: (required)
        :type onboard_single_device_args: OnboardSingleDeviceArgs
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._onboard_device_serialize(
            device_id=device_id,
            onboard_single_device_args=onboard_single_device_args,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _onboard_device_serialize(
        self,
        device_id,
        onboard_single_device_args,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if device_id is not None:
            _path_params['deviceId'] = device_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if onboard_single_device_args is not None:
            _body_params = onboard_single_device_args



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/devices/{deviceId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def onboard_devices(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OnboardDevices202Response:
        """OnboardDevices

        [Onboard](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) and associate one or more devices with your nRF Cloud account by posting CSV data.  This endpoint supports two onboarding modalities depending upon whether you include device certificates or public keys in your CSV Payload.  Uploading a device certificate allows the device to use nRF Cloud services using any supported connectivity protocol, such as HTTP/REST, MQTT, and CoAP. This is the recommended method for onboarding devices. Unlike the [CreateDeviceCertificate endpoint](#operation/CreateDeviceCertificate), this endpoint involves your own CA certificate and requires you to upload device certificates that you have already obtained, whether via a CSR produced by the `AT%KEYGEN` command (modem firmware v1.3+), or offline via your own script. We impose no rules on your CA certificate, and a self-signed certificate may be used. For more information see [Onboarding](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) in the nRF Cloud documentation.  Whether using our APIs via REST or MQTT you will need to flash to your device: 1. <a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem\" target=\"_blank\">The Amazon Root CA1 PEM file</a>, which enables the device to authenticate the AWS IoT server. 2. The private key associated with the device certificate.  Additionally, if the device will be using MQTT, you will also need to flash the device certificate. For [signing JWTs](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) you will use the private key associated with the certificate. (During the device onboarding process we extract the corresponding public key from your uploaded certificate and use this for JWT signature verification.)  The second onboarding modality involves uploading a public key to verify the signatures of [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device. Uploading a public key allows the device to use  [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) signed by the private key of an asymmetric key pair, i.e., a private key that is different than the one used to sign the device's CSR (this key pair can be generated via the AT%KEYGEN command). If you are using JWTs signed by the device CSR key, and you have also uploaded the device's certificate via this or the [OnboardDevices endpoint](#operation/OnboardDevices), there is no need to upload the public key, because it is automatically extracted from the certificate. This is useful for devices that only want to consume nRF Cloud services over REST.  Please note: Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,[subType],[tags],[fwTypes],\"certPem\"`, where:  |Field|Required?|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`subType`|No|A custom [device type](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Properties/Types.html) (for example `humidity-sensor`) to help you better recognize or categorize your devices. Include \"gateway\" in your subType if you want to provision it as a `Gateway`. This will give the device additional MQTT permissions for gateway-related topics. Otherwise, it is onboarded as a `Generic` device.|`/[a-zA-Z0-9_.,@/:#-]{0,799}/`| |`tags`|No|A list of pipe-delimited tags to create groups of devices (e.g., `warehouse\\|sensor\\|east`)|Each tag:<br/>`/^[a-zA-Z0-9_.@:#-]+$/`| |`fwTypes`|No|A list of pipe-delimited firmware types that each device supports for FOTA (e.g., `APP\\|MODEM`)|Each type:<br/>`/^(APP\\|MODEM\\|BOOT\\|SOFTDEVICE\\|BOOTLOADER\\|MDM_FULL)$/`| |`certPem`|Yes|Dependending on the onboarding modality, either a unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) X.509 certificate OR public key in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)$/` OR `/^-{5}BEGIN PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Examples of CSV rows:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,my-thing-type,tag1|tag2,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>    #### `subType` not set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,tag1|tag2,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>    #### `subType` and `tags` not set, but supported `fwTypes` are set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>  #### Using the public key modality    * <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,,APP|MODEM,\"\"-----BEGIN PUBLIC KEY-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END PUBLIC KEY-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 cert when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia. To synchronously provision a single device, you can also use the [OnboardDevice endpoint](#operation/OnboardDevice).

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._onboard_devices_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def onboard_devices_with_http_info(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OnboardDevices202Response]:
        """OnboardDevices

        [Onboard](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) and associate one or more devices with your nRF Cloud account by posting CSV data.  This endpoint supports two onboarding modalities depending upon whether you include device certificates or public keys in your CSV Payload.  Uploading a device certificate allows the device to use nRF Cloud services using any supported connectivity protocol, such as HTTP/REST, MQTT, and CoAP. This is the recommended method for onboarding devices. Unlike the [CreateDeviceCertificate endpoint](#operation/CreateDeviceCertificate), this endpoint involves your own CA certificate and requires you to upload device certificates that you have already obtained, whether via a CSR produced by the `AT%KEYGEN` command (modem firmware v1.3+), or offline via your own script. We impose no rules on your CA certificate, and a self-signed certificate may be used. For more information see [Onboarding](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) in the nRF Cloud documentation.  Whether using our APIs via REST or MQTT you will need to flash to your device: 1. <a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem\" target=\"_blank\">The Amazon Root CA1 PEM file</a>, which enables the device to authenticate the AWS IoT server. 2. The private key associated with the device certificate.  Additionally, if the device will be using MQTT, you will also need to flash the device certificate. For [signing JWTs](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) you will use the private key associated with the certificate. (During the device onboarding process we extract the corresponding public key from your uploaded certificate and use this for JWT signature verification.)  The second onboarding modality involves uploading a public key to verify the signatures of [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device. Uploading a public key allows the device to use  [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) signed by the private key of an asymmetric key pair, i.e., a private key that is different than the one used to sign the device's CSR (this key pair can be generated via the AT%KEYGEN command). If you are using JWTs signed by the device CSR key, and you have also uploaded the device's certificate via this or the [OnboardDevices endpoint](#operation/OnboardDevices), there is no need to upload the public key, because it is automatically extracted from the certificate. This is useful for devices that only want to consume nRF Cloud services over REST.  Please note: Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,[subType],[tags],[fwTypes],\"certPem\"`, where:  |Field|Required?|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`subType`|No|A custom [device type](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Properties/Types.html) (for example `humidity-sensor`) to help you better recognize or categorize your devices. Include \"gateway\" in your subType if you want to provision it as a `Gateway`. This will give the device additional MQTT permissions for gateway-related topics. Otherwise, it is onboarded as a `Generic` device.|`/[a-zA-Z0-9_.,@/:#-]{0,799}/`| |`tags`|No|A list of pipe-delimited tags to create groups of devices (e.g., `warehouse\\|sensor\\|east`)|Each tag:<br/>`/^[a-zA-Z0-9_.@:#-]+$/`| |`fwTypes`|No|A list of pipe-delimited firmware types that each device supports for FOTA (e.g., `APP\\|MODEM`)|Each type:<br/>`/^(APP\\|MODEM\\|BOOT\\|SOFTDEVICE\\|BOOTLOADER\\|MDM_FULL)$/`| |`certPem`|Yes|Dependending on the onboarding modality, either a unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) X.509 certificate OR public key in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)$/` OR `/^-{5}BEGIN PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Examples of CSV rows:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,my-thing-type,tag1|tag2,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>    #### `subType` not set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,tag1|tag2,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>    #### `subType` and `tags` not set, but supported `fwTypes` are set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>  #### Using the public key modality    * <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,,APP|MODEM,\"\"-----BEGIN PUBLIC KEY-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END PUBLIC KEY-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 cert when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia. To synchronously provision a single device, you can also use the [OnboardDevice endpoint](#operation/OnboardDevice).

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._onboard_devices_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def onboard_devices_without_preload_content(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """OnboardDevices

        [Onboard](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) and associate one or more devices with your nRF Cloud account by posting CSV data.  This endpoint supports two onboarding modalities depending upon whether you include device certificates or public keys in your CSV Payload.  Uploading a device certificate allows the device to use nRF Cloud services using any supported connectivity protocol, such as HTTP/REST, MQTT, and CoAP. This is the recommended method for onboarding devices. Unlike the [CreateDeviceCertificate endpoint](#operation/CreateDeviceCertificate), this endpoint involves your own CA certificate and requires you to upload device certificates that you have already obtained, whether via a CSR produced by the `AT%KEYGEN` command (modem firmware v1.3+), or offline via your own script. We impose no rules on your CA certificate, and a self-signed certificate may be used. For more information see [Onboarding](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html) in the nRF Cloud documentation.  Whether using our APIs via REST or MQTT you will need to flash to your device: 1. <a href=\"https://www.amazontrust.com/repository/AmazonRootCA1.pem\" target=\"_blank\">The Amazon Root CA1 PEM file</a>, which enables the device to authenticate the AWS IoT server. 2. The private key associated with the device certificate.  Additionally, if the device will be using MQTT, you will also need to flash the device certificate. For [signing JWTs](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) you will use the private key associated with the certificate. (During the device onboarding process we extract the corresponding public key from your uploaded certificate and use this for JWT signature verification.)  The second onboarding modality involves uploading a public key to verify the signatures of [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device. Uploading a public key allows the device to use  [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) signed by the private key of an asymmetric key pair, i.e., a private key that is different than the one used to sign the device's CSR (this key pair can be generated via the AT%KEYGEN command). If you are using JWTs signed by the device CSR key, and you have also uploaded the device's certificate via this or the [OnboardDevices endpoint](#operation/OnboardDevices), there is no need to upload the public key, because it is automatically extracted from the certificate. This is useful for devices that only want to consume nRF Cloud services over REST.  Please note: Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,[subType],[tags],[fwTypes],\"certPem\"`, where:  |Field|Required?|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`subType`|No|A custom [device type](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Properties/Types.html) (for example `humidity-sensor`) to help you better recognize or categorize your devices. Include \"gateway\" in your subType if you want to provision it as a `Gateway`. This will give the device additional MQTT permissions for gateway-related topics. Otherwise, it is onboarded as a `Generic` device.|`/[a-zA-Z0-9_.,@/:#-]{0,799}/`| |`tags`|No|A list of pipe-delimited tags to create groups of devices (e.g., `warehouse\\|sensor\\|east`)|Each tag:<br/>`/^[a-zA-Z0-9_.@:#-]+$/`| |`fwTypes`|No|A list of pipe-delimited firmware types that each device supports for FOTA (e.g., `APP\\|MODEM`)|Each type:<br/>`/^(APP\\|MODEM\\|BOOT\\|SOFTDEVICE\\|BOOTLOADER\\|MDM_FULL)$/`| |`certPem`|Yes|Dependending on the onboarding modality, either a unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) X.509 certificate OR public key in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)$/` OR `/^-{5}BEGIN PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Examples of CSV rows:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,my-thing-type,tag1|tag2,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>    #### `subType` not set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,tag1|tag2,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>    #### `subType` and `tags` not set, but supported `fwTypes` are set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,,APP|MODEM,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>  #### Using the public key modality    * <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,,,APP|MODEM,\"\"-----BEGIN PUBLIC KEY-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END PUBLIC KEY-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 cert when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia. To synchronously provision a single device, you can also use the [OnboardDevice endpoint](#operation/OnboardDevice).

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._onboard_devices_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _onboard_devices_serialize(
        self,
        content_type,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['content-type'] = content_type
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/devices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def register_certificates(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OnboardDevices202Response:
        """RegisterCertificates

        Register one or more device certificates. If a device has already been added to your team (onboarded) this will delete its existing cert and replace it with the new one. It is recommended to update existing devices with their new certificates before registering them here. If it is not onboarded, please use the [OnboardDevice endpoint](#operation/OnboardDevice) to complete the process which allows your device(s) to use nRF Cloud.  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,\"certPem\"`, where:  |Field|Required|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`certPem`|Yes|A unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) X.509 certificate in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Example of a CSV row:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices/certificates \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 public key when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia.

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_certificates_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def register_certificates_with_http_info(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OnboardDevices202Response]:
        """RegisterCertificates

        Register one or more device certificates. If a device has already been added to your team (onboarded) this will delete its existing cert and replace it with the new one. It is recommended to update existing devices with their new certificates before registering them here. If it is not onboarded, please use the [OnboardDevice endpoint](#operation/OnboardDevice) to complete the process which allows your device(s) to use nRF Cloud.  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,\"certPem\"`, where:  |Field|Required|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`certPem`|Yes|A unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) X.509 certificate in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Example of a CSV row:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices/certificates \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 public key when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia.

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_certificates_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def register_certificates_without_preload_content(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """RegisterCertificates

        Register one or more device certificates. If a device has already been added to your team (onboarded) this will delete its existing cert and replace it with the new one. It is recommended to update existing devices with their new certificates before registering them here. If it is not onboarded, please use the [OnboardDevice endpoint](#operation/OnboardDevice) to complete the process which allows your device(s) to use nRF Cloud.  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,\"certPem\"`, where:  |Field|Required|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`certPem`|Yes|A unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) X.509 certificate in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END CERTIFICATE-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Example of a CSV row:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,\"-----BEGIN CERTIFICATE-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END CERTIFICATE-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices/certificates \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 public key when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia.

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_certificates_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _register_certificates_serialize(
        self,
        content_type,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['content-type'] = content_type
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/devices/certificates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def register_public_keys(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OnboardDevices202Response:
        """RegisterPublicKeys

        Register one or more public keys so that the signatures for [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device can be verified.  This endpoint supports two main use cases: 1. Devices that <strong>are not onboarded</strong> on nRF Cloud that also want to consume Location Service endpoints over REST. This requires [JWT authentication](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html). Please note: <ol type=\"a\"> <li>Unlike Location Services, REST-based consumption of Firmware Over-the-Air Update endpoints requires cloud-onboarding. We recommend using the <a href=\"/v1#operation/OnboardDevices\">OnboardDevices endpoint</a>. <li>You are still able to cloud-provision devices for which you have registered public keys. There is no conflict there. <li>Devices that are not onboarded on nRF Cloud cannot use MQTT. </ol> 2. Devices that <strong>are [onboarded](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html)</strong> on nRF Cloud that want to use a dedicated private key for signing JWTs instead of using the key associated with its cloud-onboarding certificate (e.g., they were onboarded with the [OnboardDevices endpoint](#operation/OnboardDevices), which automatically extracts and stores a public key during the onboarding process for use in subsequent JWT signature verifications).  Only one public key may be registered for each device. Uploading CSV data with a different key for the same device will overwrite the existing key.  Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,\"keyPem\"`, where:  |Field|Required|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`keyPem`|Yes|A unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) public key in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Example of a CSV row:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,\"-----BEGIN PUBLIC KEY-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END PUBLIC KEY-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices/public-keys \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 public key when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia.

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_public_keys_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def register_public_keys_with_http_info(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OnboardDevices202Response]:
        """RegisterPublicKeys

        Register one or more public keys so that the signatures for [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device can be verified.  This endpoint supports two main use cases: 1. Devices that <strong>are not onboarded</strong> on nRF Cloud that also want to consume Location Service endpoints over REST. This requires [JWT authentication](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html). Please note: <ol type=\"a\"> <li>Unlike Location Services, REST-based consumption of Firmware Over-the-Air Update endpoints requires cloud-onboarding. We recommend using the <a href=\"/v1#operation/OnboardDevices\">OnboardDevices endpoint</a>. <li>You are still able to cloud-provision devices for which you have registered public keys. There is no conflict there. <li>Devices that are not onboarded on nRF Cloud cannot use MQTT. </ol> 2. Devices that <strong>are [onboarded](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html)</strong> on nRF Cloud that want to use a dedicated private key for signing JWTs instead of using the key associated with its cloud-onboarding certificate (e.g., they were onboarded with the [OnboardDevices endpoint](#operation/OnboardDevices), which automatically extracts and stores a public key during the onboarding process for use in subsequent JWT signature verifications).  Only one public key may be registered for each device. Uploading CSV data with a different key for the same device will overwrite the existing key.  Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,\"keyPem\"`, where:  |Field|Required|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`keyPem`|Yes|A unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) public key in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Example of a CSV row:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,\"-----BEGIN PUBLIC KEY-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END PUBLIC KEY-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices/public-keys \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 public key when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia.

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_public_keys_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def register_public_keys_without_preload_content(
        self,
        content_type: RestApiPayloadContentTypeWithCsv,
        body: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """RegisterPublicKeys

        Register one or more public keys so that the signatures for [JSON Web Tokens (JWTs)](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html) sent by the device can be verified.  This endpoint supports two main use cases: 1. Devices that <strong>are not onboarded</strong> on nRF Cloud that also want to consume Location Service endpoints over REST. This requires [JWT authentication](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Security/JWT.html). Please note: <ol type=\"a\"> <li>Unlike Location Services, REST-based consumption of Firmware Over-the-Air Update endpoints requires cloud-onboarding. We recommend using the <a href=\"/v1#operation/OnboardDevices\">OnboardDevices endpoint</a>. <li>You are still able to cloud-provision devices for which you have registered public keys. There is no conflict there. <li>Devices that are not onboarded on nRF Cloud cannot use MQTT. </ol> 2. Devices that <strong>are [onboarded](https://docs.nordicsemi.com/bundle/nrf-cloud/page/Devices/Associations/Onboarding.html)</strong> on nRF Cloud that want to use a dedicated private key for signing JWTs instead of using the key associated with its cloud-onboarding certificate (e.g., they were onboarded with the [OnboardDevices endpoint](#operation/OnboardDevices), which automatically extracts and stores a public key during the onboarding process for use in subsequent JWT signature verifications).  Only one public key may be registered for each device. Uploading CSV data with a different key for the same device will overwrite the existing key.  Public keys must be [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256). For more information, see the [nRF Cloud REST Authentication documentation](https://docs.nordicsemi.com/bundle/nrf-cloud/page/APIs/REST/RESTOverview.html#authentication).  This endpoint supports [asynchronous bulk operations](#tag/Bulk-Ops-Requests). Your data will be validated, and if valid, you will receive an HTTP 202 response with a `bulkOpsRequestId`. You can use this id with the bulk ops endpoints to track the request's processing status. If the bulk ops request indicates FAILED status, check the JSON errors file (URL in the bulk ops request details), fix the offending rows, then re-submit the CSV with only those rows.  Each CSV row must in the format `deviceId,\"keyPem\"`, where:  |Field|Required|Description|Validation Pattern| |---|:---:|---|---| |`deviceId`<div style=\"width:90px\"></div>|Yes|A globally unique device id (UUIDs are highly recommended)|`/^[a-z0-9:_-]{1,128}$/i`| |`keyPem`|Yes|A unique [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) public key in PEM format, wrapped in double quotes (to allow for line breaks in CSV)|`/^-{5}BEGIN PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)([^-]+)(\\r\\n\\|\\r\\|\\n)-{5}END PUBLIC KEY-{5}(\\r\\n\\|\\r\\|\\n)$/`|  Example of a CSV row:    #### All values set <span style=\"font-family:Courier\">f69c0e45-7f04-4949-8def-bb2215b4223e,\"-----BEGIN PUBLIC KEY-----<br/>MIIB7DCCAZMCFD...Av3CVgjzn5BLS03X7lyf4w==<br/> -----END PUBLIC KEY-----<br/>\"</span>  Also note:    * Max number of rows is 1000.    * Do not use a header.    * Do not leave any blank lines.  Example of uploading CSV data as a binary file:  ```sh curl -X POST $API_HOST/v1/devices/public-keys \\ --data-binary @$PATH_TO_CSV_FILE \\ -H \"Content-Type: application/octet-stream\" \\ -H \"Authorization: Bearer $API_KEY\" ``` Note that for some unknown reason, curl will strip the final line break in each ES256 public key when sending the CSV file using a non-binary content-type, e.g., using syntax such as `-d @$PATH_TO_CSV_FILE -H \"Content-Type: text/csv\"`. Therefore, with curl use `--data-binary` only. If you want to send the CSV as text, use a REST client like Postman or Insomnia.

        :param content_type: (required)
        :type content_type: RestApiPayloadContentTypeWithCsv
        :param body: (required)
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_public_keys_serialize(
            content_type=content_type,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "OnboardDevices202Response",
            '422': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _register_public_keys_serialize(
        self,
        content_type,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if content_type is not None:
            _header_params['content-type'] = content_type
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/devices/public-keys',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_device_state(
        self,
        device_id: Annotated[str, Field(strict=True)],
        device_state_input: DeviceStateInput,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """UpdateDeviceState

        Modify the device's state as stored in its shadow. You do not have to pass the entire shadow. You can update a specific portion by setting the correct JSON field path: ```sh export DEVICE_VERSION=$(curl $API_HOST/v1/devices/$DEVICE_ID -H \"Authorization: Bearer $API_KEY\" | jq -r '.[\"$meta\"].version') curl -X PATCH $API_HOST/v1/devices/$DEVICE_ID/state -d '{ \"reported\": { \"device\": { \"serviceInfo\": { \"fota_v1\": [\"BOOT\"] } } } }' -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: application/json\" -H \"If-Match: $DEVICE_VERSION\" ```

        :param device_id: (required)
        :type device_id: str
        :param device_state_input: (required)
        :type device_state_input: DeviceStateInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_state_serialize(
            device_id=device_id,
            device_state_input=device_state_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_device_state_with_http_info(
        self,
        device_id: Annotated[str, Field(strict=True)],
        device_state_input: DeviceStateInput,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """UpdateDeviceState

        Modify the device's state as stored in its shadow. You do not have to pass the entire shadow. You can update a specific portion by setting the correct JSON field path: ```sh export DEVICE_VERSION=$(curl $API_HOST/v1/devices/$DEVICE_ID -H \"Authorization: Bearer $API_KEY\" | jq -r '.[\"$meta\"].version') curl -X PATCH $API_HOST/v1/devices/$DEVICE_ID/state -d '{ \"reported\": { \"device\": { \"serviceInfo\": { \"fota_v1\": [\"BOOT\"] } } } }' -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: application/json\" -H \"If-Match: $DEVICE_VERSION\" ```

        :param device_id: (required)
        :type device_id: str
        :param device_state_input: (required)
        :type device_state_input: DeviceStateInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_state_serialize(
            device_id=device_id,
            device_state_input=device_state_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_device_state_without_preload_content(
        self,
        device_id: Annotated[str, Field(strict=True)],
        device_state_input: DeviceStateInput,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """UpdateDeviceState

        Modify the device's state as stored in its shadow. You do not have to pass the entire shadow. You can update a specific portion by setting the correct JSON field path: ```sh export DEVICE_VERSION=$(curl $API_HOST/v1/devices/$DEVICE_ID -H \"Authorization: Bearer $API_KEY\" | jq -r '.[\"$meta\"].version') curl -X PATCH $API_HOST/v1/devices/$DEVICE_ID/state -d '{ \"reported\": { \"device\": { \"serviceInfo\": { \"fota_v1\": [\"BOOT\"] } } } }' -H \"Authorization: Bearer $API_KEY\" -H \"Content-Type: application/json\" -H \"If-Match: $DEVICE_VERSION\" ```

        :param device_id: (required)
        :type device_id: str
        :param device_state_input: (required)
        :type device_state_input: DeviceStateInput
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_device_state_serialize(
            device_id=device_id,
            device_state_input=device_state_input,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_device_state_serialize(
        self,
        device_id,
        device_state_input,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if device_id is not None:
            _path_params['deviceId'] = device_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if device_state_input is not None:
            _body_params = device_state_input



        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'Simple Token', 
            'JSON Web Token'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/devices/{deviceId}/state',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


